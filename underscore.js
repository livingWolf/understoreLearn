(function() {    //self对象指窗口本身，返回的对象跟window对象是一模一样的。    //root对象在浏览器中表示为self，在node.js（服务器端）中表示为global对象。    //之所以用self是为了支持web worker    var root = typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global || this || {};    //保存变量"_"被覆盖之前的值    //如果出现命名冲突或考虑到规范，可通过_.noConflict()方法恢复"_"被underscore占用之前的值，并返回Underscore对象以便重新命名    var previousUnderscore = root._;    //将内置对象原型中的常用方法赋值给引用变量，以便更方便的使用    var ArrayProto = Array.prototype,        ObjProto = Object.prototype;    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;    var push = ArrayProto.push,        slice = ArrayProto.slice,        toString = ObjProto.toString,        hasOwnProperty = ObjProto.hasOwnProperty;    //ECMScript5的一些方法     var nativeIsArray = Array.isArray,        nativeKeys = Object.keys,        nativeCreate = Object.create;    //创建一个函数，为后面数据处理        var Ctor = function() {};    //this指向window    var _ = function(obj) {        //当obj.__proto__(隐形原型)与_.prototype(显示原型)相同时候，判断obj是否是_的实例        if (obj instanceof _) return obj;        //如果不是，重新构造一个        if (!(this instanceof _)) return new _(obj);        //将obj对象存放在_wrapped中；        this._wrapped = obj;    };    //判断不同环境支持的模块加载机制，如果是node的环境则用module.exports导出，否则直接挂载在全局对象，undefined有两种可能，browser和node两种    if (typeof exports != 'undefined' && !exports.nodeType) {        if (typeof module != 'undefined' && !module.nodeType && module.exports) {            exports = module.exports = _;        }        exports._ = _;    } else { //浏览器        root._ = _;    }    //版本号    _.VERSION = '1.8.3';    //argCount为函数参数的个数，针对不同参数个数进行不同的处理    var optimizeCb = function(func, context, argCount) {        //当没有上下文时候，返回当前函数；void返回值都是undefined，之所以写成void 0是（在es5之前），window下的undefined被重写，导致某些极端情况下使用undefined会出现一定的差错。        if (context === void 0) return func;        switch (argCount) {            //为单值得情况，如times函数            case 1:                return function(value) {                    return func.call(context, value);                };                //两个参数的情况没有用到            case null:                //三个参数用于一些迭代器函数，如map函数            case 3:                return function(value, index, collection) {                    return func.call(context, value, index, collection);                };                //四个参数用于reduce和reduceRight函数            case 4:                return function(accumulator, value, index, collection) {                    return func.call(context, accumulator, value, index, collection);                };        }        return function() {            return func.apply(context, arguments);        };    };    var builtinIteratee;    //为每个元素生成回调    var cb = function(value, context, argCount) {        //当迭代未到底时候，继续迭代        if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);        //如果为空，则返回value本身，即return null        if (value == null) return _.identity;        //如果是对象，则改变执行函数的作用域        if (_.isFunction(value)) return optimizeCb(value, context, argCount);        //如果是对象，判断是否匹配        if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);    };    //迭代函数：如裴波那契数列，即f(n)=f(n-1)+f(n-2);    //主要：1、确定迭代变量；2、建立迭代关系式；3、对迭代过程进行控制；    _.iteratee = builtinIteratee = function(value, context) {        return cb(value, context, Infinity);    };    //Function.length:function参数的个数，特殊情况传入参数为arguments，只能通过arguments.length来确定    //startIndex代表从第几个参数开始当作是剩余参数    var restArgs = function(func, startIndex) {        startIndex = startIndex == null ? func.length - 1 : +startIndex;        return function() {            var length = Math.max(arguments.length - startIndex, 0),                rest = Array(length),                index = 0;            //将startIndex之后的参数放到rest数组中            for (; index < length; index++) {                rest[index] = arguments[index + startIndex];            }            //call方法需要将参数一个个传入            switch (startIndex) {                case 0:                    return func.call(this, rest);                case 1:                    return func.call(this, arguments[0], rest);                case 2:                    return func.call(this, arguments[0], arguments[1], rest);            }            //当startIndex为其他值时候（可能很大），运用apply            //遵循原则：（1）避免使用arguments（2）尽量使用call而不是apply。基于机遇性能考虑，针对老的浏览器引擎考虑            var args = Array(startIndex + 1);            for (index = 0; index < startIndex; index++) {                args[index] = arguments[index];            }            args[startIndex] = rest;            return func.apply(this, args);        };    };    //创建一个带指定原型的函数，两种方法是考虑到兼容性问题    var baseCreate = function(prototype) {        //判断prototype是否是对象，不是，则返回个对象        if (!_.isObject(prototype)) return {};        //如果Object.create存在，则创建一个指定为prototype的原型对象；        if (nativeCreate) return nativeCreate(prototype);        //将Ctor的原型对象指向prototype；        Ctor.prototype = prototype;        //返回Ctor对象；        var result = new Ctor;        //将Ctor的原型复原，设为null；注：只有函数才有prototype（显示原型）；        Ctor.prototype = null;        return result;    };    //取指定对象obj的指定key对应的value值    var shallowProperty = function(key) {        return function(obj) {            return obj == null ? void 0 : obj[key];        };    };    //如果obj为null，返回false；    //取path数组为空，返回false；    //取得对象里的对象的值，如obj = {"a" : {"b": "B"}}, path= ["a","b"],取得的值为a.b，即B    var deepGet = function(obj, path) {        var length = path.length;        for (var i = 0; i < length; i++) {            if (obj == null) return void 0;            obj = obj[path[i]];        }        return length ? obj : void 0;    }    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;    var getLength = shallowProperty('length');    //判断是否是类似数组的对象，如{"0":"a","1":"b","2":"c",length:3};    var isArrayLike = function(collection) {        var length = getLength(collection);        return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;    };    //遍历数组或对象    _.each = _.forEach = function(obj, iteratee, context) {        iteratee = optimizeCb(iteratee, context);        var i, length;        if (isArrayLike(obj)) {            for (i = 0, length = obj.length; i < length; i++) {                iteratee(obj[i], i, obj);            }        } else {            var keys = _.keys(obj);            for (i = 0, length = keys.length; i < length; i++) {                iteratee(obj[keys[i]], i, obj);            }        }        return obj;    };    //遍历数组（每个元素）或者对象的每个元素，对其进行iteratee迭代方法，将结果保存到新的数组中，并返回    _.map = _.collect = function(obj, iteratee, context) {        iteratee = cb(iteratee, context);        var keys = !isArrayLike(obj) && _.keys(obj),            length = (keys || obj).length,            results = Array(length);        for (var index = 0; index < length; index++) {            var currentKey = keys ? keys[index] : index;            results[index] = iteratee(obj[currentKey], currentKey, obj);        }        return results;    };    var createReduce = function(dir) {        var reducer = function(obj, iteratee, memo, initial) {            var keys = !isArrayLike(obj) && _.keys(obj),                length = (keys || obj).length,                index = dir > 0 ? 0 : length - 1;            if (!initial) {                memo = obj[keys ? keys[index] : index];                index += dir;            }            for (; index >= 0 && index < length; index += dir) {                var currentKey = keys ? keys[index] : index;                memo = iteratee(memo, obj[currentKey], currentKey, obj);            }            return memo;        };        return function(obj, iteratee, memo, context) {            var initial = arguments.length >= 3;            return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);        }    };    _.reduce = _.foldl = _.inject = createReduce(1);    //从后侧开始根据reduce方法组合元素    _.reduceRight = _.folder = createReduce(-1);    //在obj中逐项查找，返回第一个通过predicate真值检测的元素值    _.find = _.detect = function(obj, predicate, context){        var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;        var key = keyFinder(obj, predicate, context);        if(key !== void 0 && key !== -1) return obj[key];    }    //返回obj中通过predicate真值检测的元素集合    _.filter = _.select = function(obj, predicate, context) {        var result = [];        predicate = cb(predicate, context);        _.each(obj, function(value, index, list) {            if (predicate(value, index, list)) results.push(value);        });        return results;    }    //返回obj中没有通过predicate真值检测的元素集合    _.reject = function(obj, predicate, context){        return _.filter(obj, _.negate(predicate), context);    }    //如果obj中所有元素通过predicate的真值检测就返回true    _.every = _.all = function(obj,predicate, context){        predicate = cb(predicate, context);        var keys = !isArrayLike(obj) && _.keys(obj),            length = (keys || obj).length;        for(var index = 0; index < length; index ++) {            var currentKey = keys? key[index] : index;            if(!predicate(obj[currentKey], currentKey, obj)) return false;        }        return true;    }    //如果obj中有任何一个元素通过predicate的真值检测就返回true。    //一旦找到符合条件的元素，就直接中断遍历    _.some = _.any = function(obj, predicate, context){        predicate = cb(predicate, context);        var keys = !isArrayLike(obj) && _.keys(obj),            length = (keys || obj).length;        for(var index = 0; index < length; index ++){            var currentKey = keys ? keys[index] : index;            if(predicate(obj[currentKey], currentKey, obj)) return true;        }          return false;      }    //判断obj中是否包含item值    _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {        if (!isArrayLike(obj)) obj = _.value(obj);        if (typeof fromIndex != 'number' || guard) fromIndex = 0;        //如果存在，indexOf返回相应的索引，则为true；如果不存在，indexOf返回-1，则为false        return _.indexOf(obj, item, fromIndex) >= 0;    }    //obj上的每个元素执行path方法    _.invoke = restArgs(function(obj,path,args){        var contextPath, func;        if(_.isFunction(path)){            func = path;        }else if(_.isArray(path)){            contextPath = path.slice(0, -1);            path = path[path.length - 1];        }        return _.map(obj, function(context){            var method = func;            if(!method) {                if(contextPath && contextPath.length){                    context = deepGet(context, contextPath);                }                if(context == null) return void 0;                method = context[path];            }            return method == null ? method : method.apply(context, args);        });    });    //取数组对象中某个属性值，并返回一个数组；    _.pluck = function(obj, key) {        return _.map(obj, _.property(key));    }    //遍历obj中的每一个值，返回一个数组，这个数组包含key所列出的所有key-value对    _.where = function(obj, key) {        return _.map(obj, _.property(key));    }    //遍历整个list，返回匹配attrs参数所列出的所有key-value的第一个值    _.findWhere = function(obj, attrs) {        return _.find(obj, _.matcher(attrs));    }    //寻找数组中的最大元素，或者对象中的最大value值    //如果iteratee有参数，则求每个元素经过该函数迭代后的最值    _.max = function(obj, iteratee, context) {        var result = -Infinity,            lastComputed = -Infinity,            value, computed;        if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object') && obj != null) {            obj = isArrayLike(obj) ? obj : _.values(obj);            for (var i = 0, length = obj.length; i < length; i++) {                value = obj[i];                if (value != null && value > result) {                    result = value;                }            }        } else {            iteratee = cb(iteratee, context);            _.each(obj, function(v, index, list) {                //result保存结果元素                //lastComputed保存计算过程中出现的最值                computed = iteratee(v, index, list);                //&&的优先级高于||                if (computed > lastComputed || computed === -Infinity && result === -Infinity) {                    result = v;                    lastComputed = computed;                }            });        }        return result;    };    //取最小数    _.min = function(obj, iteratee, context) {        var result = Infinity,            lastComputed = Infinity,            value, computed;        if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object') && obj != null) {            obj = isArrayLike(obj) ? obj : _.values(obj);            for (var i = 0, length = obj.length; i < length; i++) {                value = obj[i];                if (value != null && value < result) {                    result = value;                }            }        } else {            iteratee = cb(iteratee, context);            _.each(obj, function(v, index, list) {                computed = iteratee(v, index, list);                if (computed < lastComputed || computed === Infinity && result === Infinity) {                    result = v;                    lastComputed = computed;                }            });        }        return result;    }    //返回一个随机乱序的obj副本    _.shuffle = function(obj) {        return _.sample(obj, Infinity);    }    //从obj中随机返回n个数    _.sample = function(obj, n, guard) {        if (n == null || guard) {            if (!isArrayLike(obj)) obj = _.values(obj);            return obj[_.random(obj.length - 1)];        }        var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);        var length = getLength(sample);        n = Math.max(Math.min(n, length), 0);        var last = length - 1;        for (var index = 0; index < n; index++) {            var rand = _.random(index, last);            var temp = sample[index];            sample[index] = sample[rand];            sample[rand] = temp;        }        return sample.slice(0, n);    }    //返回排序后list拷贝副本    _.sortBy = function(obj, iteratee, context) {        var index = 0;        iteratee = cb(iteratee, context);        return _.pluck(_.map(obj, function(value, key, list) {            return {                value: value,                index: index++,                criteria: iteratee(value, key, list)            };        }).sort(function(left, right) {            var a = left.criteria;            var b = right.criteria;            if (a !== b) {                if (a > b || a === void 0) return 1;                if (a < b || b === void 0) return -1;            }            return left.index - right.index;        }), 'value');    }    var group = function(behavior, partition) {        return function(obj, iteratee, context) {            var result = partition ? [                [],                []            ] : {};            iteratee = cb(iteratee, context);            _.each(obj, function(value, index) {                var key = iteratee(value, index, obj);                behavior(result, value, key);            });            return result;        }    }    //把一个集合分为多个集合，通过value返回的结果进行分组    _.groupBy = group(function(result, value, key) {        if (_.has(result, key)) result[key].push(value);        else result[key] = [value];    })    //类似groupBy，当知道key值唯一的时候，可以用该方法    _.indexBy = group(function(result, value, key) {        result[key] = value;    });    //根据value方法返回各个分组中对象的数量的计数    _.countBy = group(function(result, value, key) {        if (_.has(result, key)) result[key]++;        else result[key] = 1;    })    //返回对象的长度    _.size = function(obj) {        if (obj == null) return 0;        return isArrayLike(obj) ? obj.length : _.keys(obj).length;    }    //拆分一个数组为两部分，一部分满足iteratee迭代函数，一部分不满足    _.partition = group(function(result, value, pass) {        result[pass ? 0 : 1].push(value);    }, true);    //返回数组中的第一个元素    _.first = _.head = _.take = function(array, n, guard) {        if (array == null || array.length < 1) return void 0;        if (n == null || guard) return array[0];        return _.initial(array, array.length - n);    }    //返回数组中除最后一个元素外的其他全部元素    _.initial = function() {        return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));    }    //返回array从第一远处开始的n歌元素    _.last = function(array, n, guard) {        if (array == null || array.length < 1) return void 0;        if (n == null || guard) return array[array.length - 1];        return _.rest(array, Math.max(0, array.length - n));    }    //返回数组中从n开始的所有剩余元素    _.rest = _.tail = _.drop = function(array, n, guard) {        return slice.call(array, n == null || guard ? 1 : n);    }    //返回一个去除所有false值得array副本，    //在js中，false、null、0、“”、undefined和NaN都是false值    _.compact = function(array) {        return _.filter(array, Boolean);    }    //将数组铺平，例如[[1,2],3] => [1,2,3]    var flatten = function(input, shallow, strict, output) {        output = output || [];        var idx = output.length;        for (var i = 0, length = getLength(input); i < length; i++) {            var value = input[i];            if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {                //shallow是布尔值，为false则表示数组是深度展开；为true则表示只展开一层                if (shallow) {                    var j = 0,                        len = value.length;                    while (j < len) output[idx++] = value[j++];                } else {                    flatten(value, shallow, strict, output);                    idx = output.length;                }            } else if (!strict) {                //当shallow为false，而strict为true时候，调用flatten得到结果为[]；                //当strict为false时候，shallow也为false时候，能过滤掉input参数元素中的非数组元素                output[idx++] = value;            }        }        return output;    }    //将一个嵌套多层的数组转换为只有一层的数组    _.flatten = function(array, shallow) {        return flatten(array, shallow, false);    }    //返回一个删除所有otherArrays值后的array副本    _.without = restArgs(function(array, otherArrays) {        return _.difference(array, otherArrays);    });    //返回array去重后的副本    _.uniq = _.unique = function(array, isSorted, iteratee, context) {        if (!_.isBoolean(isSorted)) {            context = iteratee;            iteratee = isSorted;            isSorted = false;        }        if (iteratee != null) iteratee = cb(iteratee, context);        var result = [];        var seen = [];        for (var i = 0, length = getLength(array); i < length; i++) {            var value = array[i],                computed = iteratee ? iteratee(value, i, array) : value;            if (isSorted) {                if (!i || seen !== computed) result.push(value);                seen = computed;            } else if (iteratee) {                if (!_.contains(seen, computed)) {                    seen.push(computed);                    result.push(value);                }            } else if (!_.contains(result, value)) {                result.push(value);            }        }        return result;    }    //取arrays数组里的并集    _.union = restArgs(function(arrays) {        return _.uniq(flatten(arrays, true, true));    });    //取array数组里的交集    _.intersection = function(array) {        var result = [];        var argsLength = arguments.length;        for (var i = 0, length = getLength(array); i < length; i++) {            var item = array[i];            if (_.contains(result, item)) continue;            var j;            for (j = 1; j < arguments; j++) {                if (!_.contains(arguments[j], item)) break;            }            if (j === argsLength) result.push(item);        }        return result;    }    //取两个数组中不同的数值    _.difference = restArgs(function(array, rest) {        rest = flatten(rest, true, true);        return _.filter(array, function(value) {            return !_.contains(rest, value);        });    });    //给定若干arrays，返回一串联的新数组，其中第一个元素包含所有的输入数值的第一个元素，以此类推    _.unzip = function(array) {        var length = array && _.max(array, getLength).length || 0;        var result = Array(length);        for (var index = 0; index < length; index++) {            result[index] = _.pluck(array, index);        }        return result;    }    //将每个array中相应位置的值合并在一起    _.zip = restArgs(_.unzip);    //将数组转换为对象    _.object = function(list, values) {        var result = {};        for (var i = 0, length = getLength(list); i < length; i++) {            if (values) {                result[list[i]] = values[i];            } else {                result[list[i][0]] = list[i][1];            }        }        return result;    }    //    var createPredicateIndexFinder = function(dir) {        return function(array, predicate, context) {            predicate = cb(predicate, context);            var length = getLength(array);            //如果dir>0，检索从0到length-1；如果dir<0,检索从length-1到0            var index = dir > 0 ? 0 : length - 1;            for (; index >= 0 && index < length; index += dir) {                //找到第一个符合条件的元素，并返回下标值                if (predicate(array[index], index, array)) return index;            }            return -1;        }    };    _.findIndex = createPredicateIndexFinder(1);    _.findLastIndex = createPredicateIndexFinder(-1);    //二分法查找，在array中找到obj，并返回下标数（注：二分法查找，数据需要时拍好序）    _.sortedIndex = function(array, obj, iteratee, context) {        iteratee = cb(iteratee, context, 1);        var value = iteratee(obj);        var low = 0,            high = getLength(array);        while (low < high) {            var mid = Math.floor((low + high) / 2);            if (iteratee(array[mid]) < value) low = mid + 1;            else high = mid;        }        return low;    };    //返回索引检索函数    var createIndexFinder = function(dir, predicateFind, sortedIndex) {        return function(array, item, idx) {            var i = 0,                length = getLength('length');            //当不能用二分法查找时候            if (typeof idx == 'number') {                //正向查找                if (dir > 0) {                    i = idx >= 0 ? idx : Math.max(idx + length, i);                } else {                    //                    length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;                }                //如果是排序好的就使用二分法             } else if (sortedIndex && idx && length) {                idx = sortedIndex(array, item);                //判断找出的值是否一样，是就返回这个值，否则返回-1                return array[idx] === item ? idx : -1;            }            //对item为NaN的处理;表示item是个非数字的一个值，属于Number类型，NaN !== NaN;            if (item !== item) {                //Array.prototype.slice.call(arguments,1):把调用方法的参数截取出来。arguments是类数组                //slice.call(array,i,length)把array这个类数组转化为数组                idx = predicateFind(slice.call(array, i, length), _.isNaN);                return idx >= 0 ? idx + i : -1;            }            //通过遍历的方法找出item对应的索引            for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {                if (array[idx] === item) return idx;            }            return -1;        }    };    _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);    _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);    //Math.ceil()向上取整，如Math.ceil(12.2)为13    //创建灵活编号的列表的数组    _.range = function(start, stop, step) {        if (stop == null) {            stop = start || 0;            start = 0;        }        if (!step) {            step = stop < start ? -1 : 1;        }        var length = Math.max(Math.ceil((stop - start) / step), 0);        var range = Array(length);        for (var idx = 0; idx < length; idx++, start += step) {            range[idx] = start;        };        return range;    }    //将数组按count分割    _.chunk = function(array, count) {        if (count == null || count < 1) return [];        var result = [];        var i = 0,            length = array.length;        while (i < length) {            result.push(slice.call(array, i, i += count));        }        return result;    }    //函数的扩展方法，共14种    var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {        //非new调用_.bind返回的方法        if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);        //如果是用new调用_.bind返回的方法        //self为sourceFunc的实例，继承了它的原型链        //self理论上是一个空对象（还没赋值），但是有原型链        var self = baseCreate(sourceFunc.prototype);        var result = sourceFunc.apply(self, args);        if (_.isObject(result)) return result;        return self;    }    //TODO: 嘛意思？    _.bind = restArgs(function(func, context, args) {        if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');        var bound = restArgs(function(callArgs) {            return executeBound(func, bound, context, this, args, args.concat(callArgs));        });        return bound;    });    //TODO:嘛意思？    //局部应用一个函数填充在任意个数的 arguments，不改变其动态this值。和bind方法很相近    _.partial = restArgs(function(func, boundArgs) {        var placeholder = _.partial.placeholder;        var bound = function() {            var position = 0,                length = boundArgs.length;            var args = Array(length);            for (var i = 0; i < length; i++) {                args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];            }            while (position < arguments.length) args.push(arguments[position++]);            return executeBound(func, bound, this, this, args);        };        return bound;    });    _.partial.placeholder = _;    _.bindAll = restArgs(function(obj, keys) {        keys = flatten(keys, false, false);        var index = keys.length;        if (index < 1) throw new Error('bindAll must be passed function names');        while (index--) {            var key = keys[index];            obj[key] = _.bind(obj[key], obj);        }    });    //缓存某函数的计算结果    _.memoize = function(func, hasher) {        var memoize = function(key) {            var cache = memoize.cache;            var address = '' + (hasher ? hasher.apply(this, arguments) : key);            if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);            return cache[address];        };        memoize.cache = {};        return memoize;    }    //延迟执行    _.delay = restArgs(function(func, wait, args) {        return setTimeout(function() {            return func.apply(null, args);        }, wait);    });    _.defer = _.partial(_.delay, _, 1);    //频率控制 返回函数连续调用时，func执行频率限定为 次/wait    _.throttle = function(func, wait, options) {        var timeout, context, args, result;        //上传执行时间点        var previous = 0;        if (!options) options = {};        //延迟执行函数        var later = function() {            //如果设定了开始边界不执行选项，上次执行时间始终为0            previous = options.leading === false > 0: _.now();            timeout = null;            result = func.apply(context, args);            if (!timeout) context = args = null;        };        var throttled = function() {            var now = _.now();            //首次执行时候，如果设定了开始边界不执行选项，将上次执行时间设置为当前时间            if (!previous && options.leading === false) previous = now;            //延迟执行时间间隔            var remaining = wait - (now - previous);            context = this;            args = arguments;            //延迟时间间隔remaining小于等于0，表示上次执行至此所间隔时间已经超过一个时间窗口            //remaining>wait代表客户端系统时间被调整过            if (remaining <= 0 || remaining > wait) {                if (timeout) {                    clearTimeout(timeout);                    timeout = null;                }                previous = now;                result = func.apply(context, args);                if (!timeout) context = args = null;            } else if (!timeout && options.trailing !== false) {                timeout = setTimeout(later, remaining);            }            return result;        };        throttled.cancel = function() {            clearTimeout(timeout);            previous = 0;            timeout = context = args = null;        };        return throttled;    };    //空闲控制 返回函数连续调用时，空闲时间必须大于或等于wait，func才会执行    _.debounce = function(func, wait, immediate) {        var timeout, result;        var later = function(context, args) {            timeout = null;            if (args) result = func.apply(context, args);        };        var debounced = restArgs(function(args) {            if (timeout) clearTimeout(timeout);            if (immediate) {                var callNow = !timeout;                timeout = setTimeout(later, wait);                if (callNow) result = func.apply(this, args);            } else {                timeout = _.delay(later, wait, this, args);            }            return result;        });        debounced.cancel = function() {            clearTimeout(timeout);            timeout = null;        };        return debounced;    };    //先执行wrapper函数再执行func，将wrapper函数当作第一个参数传给func    _.wrap = function(func, wrapper) {        return _.partial(wrapper, func);    }    //在执行完predicate后取返回值的！值    _.negate = function(predicate) {        return function() {            return !predicate.apply(this, arguments);        }    }    //返回函数集，即一个函数执行完后把返回的结果再作为参数赋给下一个执行函数。由右向左    _.compose = function() {        var args = arguments;        var start = args.length - 1;        return function() {            var i = start;            var result = args[start].apply(this, arguments);            while (i--) result = args[i].call(this, result);            return result;        }    }    //创建一个函数，只有在运行了times后才有效果    //在处理同组异步请求返回结果时，如果要确保同组里所有的异步请求完成之后才能执行这个函数，非常有用    _.after = function(times, func) {        return function() {            if (--times < 1) {                return func.apply(this, arguments);            }        }    }    //创建一个函数，调用不超过times次。当times已经达标时候，最后一个函数调用的结果将会被记住并返回    _.before = function(times, func) {        var memo;        return function() {            if (--times > 0) {                memo = func.apply(this, arguments);            }            if (times <= 1) func = null;            return memo;        }    };    //创建一个只能调用一次的函数    _.once = _.partial(_.before, 2);    _.restArgs = restArgs;    //Object.prototype.propertyIsEnumerable()返回一个boolean，表明指定属性是否可以通过for...in遍历到，但是是原型链上的属性也会返回false    //覆盖对象原型的toString，看是否能够遍历到，不能的话hasEnumBug为true，针对IE9以下的bug    var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');    //所有需要处理的可能存在枚举问题的属性    var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];    //处理IE9以下的枚举bug    var collectNonEnumProps = function(obj, keys) {        var nonEnumIdx = nonEnumerableProps.length;        var constructor = obj.constructor;        //TODO：取原型，怎么取得？        var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;        var prop = 'constructor';        if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);        while (nonEnumIdx--) {            prop = nonEnumerableProps[nonEnumIdx];            if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {                keys.push(prop);            }        }    };    //遍历对象的keys值，并返回    _.keys = function(obj) {        //如果obj不为对象，返回空数组        if (!_.isObject(obj)) return [];        //如果Object.keys方法存在，即支持原生的方法时候，返回obj对象的keys        if (nativeKeys) return nativeKeys(obj);        //当不支持原生方法时候，取obj得keys        var keys = [];        //for in 会遍历原型链上的key，所以用_.has来确保读取的只是对象本身的属性        for (var key in obj)            if (_.has(obj, key)) keys.push(key);        //IE<9的枚举bug的兼容处理        if (hasEnumBug) collectNonEnumProps(obj, keys);        return keys;    }    //遍历obj里所有的keys值，包括继承过来的属性    _.allKeys = function(obj) {        if (!_.isObject(obj)) return [];        var keys = [];        for (var key in obj) keys.push(key);        return keys;    }    //取object对象的key对应的value，返回数组    _.values = function(obj) {        var keys = _.keys(obj);        var length = keys.length;        var values = Array(length);        for (var i = 0; i < length; i++) {            values[i] = obj[keys[i]];        }        return values;    };    //转换每个属性的值    _.mapObject = function(obj, iteratee, context) {        iteratee = cb(iteratee, context);        var keys = _.keys(obj),            length = keys.length,            results = {};        for (var index = 0; index < length; index++) {            var currentKey = keys[index];            results[currentKey] = iteratee(obj[currentKey], currentKey, obj);        }        return results;    }    //将一个对象转变为一个[key,value]形式的数组    _.pairs = function(obj) {        var keys = _.keys(obj);        var length = keys.length;        var pairs = Array(length);        for (var i = 0; i < length; i++) {            pairs[i] = [key[i], obj[keys[i]]];        }        return pairs;    }    //将对象的key-value值反过来变成value-key    _.invert = function(obj) {        var result = {};        var keys = _.keys(obj);        for (var i = 0, length = keys.length; i < length; i++) {            result[obj[keys[i]]] = keys[i];        }        return result;    }    //返回一个对象里所有的方法名，并排序好    _.functions = _.method = function(obj) {        var names = [];        for (var key in obj) {            if (_.isFunction(obj[key])) name.push(key);        }        return names.sort();    }    // arguments对象的长度由实参个数而不是形参个数决定的    // obj为第一个对象，其余对象在arguments里，这段代码大概意思是通过keysFunc方法，将其余参数里的数据进行处理，复制到obj，第一个对象里    var createAssigner = function(keysFunc, defaults) {        return function(obj) {            var length = arguments.length;            if (defaults) obj = Object(obj);            if (length < 2 || obj == null) return obj;            for (var index = 1; index < length; index++) {                var source = arguments[index],                    keys = keysFunc(source),                    l = keys.length;                for (var i = 0; i < l; i++) {                    var key = keys[i];                    if (!defaults || obj[key] === void 0) obj[key] = source[key];                }            }            return obj;        }    }    _.extend = createAssigner(_.allKeys);    //复制自己的属性覆盖到目标对象（不包括继承过来的属性）    _.extendOwn = _.assign = createAssigner(_.keys);    //根据predicate条件查找到obj中相应的key    _.findKey = function(obj, predicate, context) {        predicate = cb(predicate, context);        var keys = _.keys(obj),            key;        for (var i = 0, length = keys.length; i < length; i++) {            key = keys[i];            if (predicate(obj[key], key, obj)) return key;        }    }    var keyInObj = function(value, key, obj) {        return key in obj;    }    //返回一个object副本，只过滤出keys参数指定的属性值。或者接受一个判断函数，指定挑选哪个key    _.pick = restArgs(function(obj, keys) {        var result = {},            iteratee = key[0];        if (obj == null) return result;        if (_.isFunction(iteratee)) {            if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);            keys = _.allKeys(obj);        } else {            iteratee = keyInObj;            keys = flatten(keys, false, false);            obj = Object(obj);        }        for (var i = 0, length = keys.length; i < length; i++) {            var key = keys[i];            var value = obj[key];            if (iteratee(value, key, obj)) result[key] = value;        }        return result;    });    //返回一个object副本，只过滤除去keys（有效的键组成的数组）参数指定的属性值。或者接受一个判断函数，指定忽略哪个key    _.omit = restArgs(function(obj, keys) {        var iteratee = keys[0],            context;        if (_.isFunction(iteratee)) {            iteratee = _.negate(iteratee);            if (keys.length > 1) context = key[1];        } else {            keys = _.map(flatten(keys, false, false), String);            iteratee = function(value, key) {                return !_.contains(keys, key);            };        }        return _.pick(obj, iteratee, context);    });    //如果defaults里出现了和object中一样的键，则不覆盖object的键值对    //如果defaults多个参数对象中相同的key的对象，则取最早出现的value值    _.defaults = createAssigner(_.allKeys, true);    //给定原型和一些own properties，构造一个新的对象并返回    _.create = function(prototype, props) {        var result = baseCreate(prototype);        if (props) _.extendOwn(result, props);        return result;    }    //浅拷贝跟深拷贝的区别：浅拷贝只是拷贝了引用到内存地址；而深拷贝新建一个内存，并把之前内存数据存储进去，引用至新的内存。所以当原对象发生变化时候，拷贝也不会发生改变    //这里是浅拷贝    _.clone = function(obj) {        if (!_.isObject(obj)) return obj;        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);    }    //主要是作为函数链式调用的一环，为了对此对象执行操作并返回对象本身    _.tap = function(obj, interceptor) {        interceptor(obj);        return obj;    }    // 判断object里是否包含attrs    _.isMatch = function(object, attrs) {        var keys = _.keys(attrs),            length = keys.length;        if (object == null) return !length;        var obj = Object(object);        for (var i = 0; i < length; i++) {            var key = keys[i];            if (attrs[key] != obj[key] || !(key in obj)) return false;        };        return true;    };    //判断a与b相等    //TODO: Symbol(ES6新增的第七种类型)    var eq, deepEq;    eq = function(a, b, aStack, bStack) {        //js规定中 0和-0是不相同的        //但是 0 === -0 会返回true        // 1/0 是Infinity（正无穷大），1/-0 是-Infinity，负无穷大        if (a === b) return a !== 0 || 1 / a === 1 / b;        //严格模式下， null和undefined只等于其自身        if (a == null || b == null) return false;        //NaN不等于自身,当a为NaN时候，b也不等于自身，则为b与a相等        if (a !== a) return b !== b;        var type = typeof a;        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;        return deepEq(a, b, aStack, bStack);    };    deepEq = function() {        if (a instanceof _) a = a._wrapped;        if (b instanceof _) b = b._wrapped;        var className = toString.call(a);        if (className !== toString.call(b)) return false;        switch (className) {            case '[object RegExp]':            case '[object String]':                return '' + a === '' + b;            case '[object Number]':                if (+a !== +a) return +b !== +b;                return +a === 0 ? 1 / +a === 1 / b : +a === +b;                //Date类型时候， + new Date()是当前时间距离1970年1月1日0秒的毫秒数                //+true 为1，+false+为0            case '[object Date]':            case '[object Boolean]':                return +a === +b;            case '[object Symbol]':                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);        }        var areArrays = className === '[object Array]';        if (!areArrays) {            if (typeof a != 'object' || typeof b != 'object') return false;            //得到a和b的构造函数            //不同构造函数的对象不相等            var aCtor = a.constructor,                bCtor = b.constructor;            if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {                return false;            }        }        aStack = aStack || [];        bStack = bStack || [];        var length = aStack.length;        //TODO ： 嘛意思？        while (length--) {            if (aStack[length] === a) return bStack[length] === b;        }        aStack.push(a);        bStack.push(b);        if (areArrays) {            length = a.length;            if (length !== b.length) return false;            while (length--) {                if (!eq(a[length], b[length], aStack, bStack)) return false;            }        } else {            var keys = _.keys(a),                key;            length = keys.length;            if (_.keys(b).length !== length) return false;            while (length--) {                key = keys[length];                if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;            }        }        aStack.pop();        bStack.pop();        return true;    };    _.isEqual = function(a, b) {        return eq(a, b);    }    //判断obj是否为空    _.isEmpty = function(obj) {        if (obj == null) return true;        if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)))            return obj.length === 0;        return _.keys(obj).length === 0;    }    //判断obj是否是dom元素    _.isElement = function(obj) {        return !!(obj && obj.nodeType === 1);    }    //判断obj是否是数组    //typeOf只能区分五大基本类型，即“number”，“string”，“undefined”，“boolean”，“object”    //要区分数组还是对象，可以使用Object.prototype.toString.call()方法，返回为[object Number],[object String],[object Undefined], [object Boolean], [object Object], [object Array], [object Function]    _.isArray = nativeIsArray || function(obj) {        return toString.call(obj) === '[object Array]';    }    //判断obj是否有值，没有返回false；    //判断obj类型是否是函数或对象，是则为true    _.isObject = function(obj) {        var type = typeof obj;        //对于null 与 undefined 用！操作符都会产生true；!!意义：如果obj里有值的话为true，里面没有设置值得话，值为false，而不会是null 或者 undefined        return type === 'function' || type === 'object' && !!obj;    };    //判断类型     _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {        _['is' + name] = function(obj) {            return toString.call(obj) === '[object' + name + ']';        };    })    //ie9以下，没有arguments属性    //判断obj是否是一个参数对象     //TODO 嘛意思    if (!_.isArguments(arguments)) {        _.isArguments = function(obj) {            return _.has(obj, 'callee');        }    }    //TODO:嘛意思？？？？？    var nodelist = root.document && root.document.childNodes;    if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {        _.isFunction = function(obj) {            return typeof obj === 'function' || false;        }    }    //isFinite()检测无穷数    _.isFinite = function(obj) {        return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));    }    //TODO: isNumber()?    _.isNaN = function(obj) {        return _.isNumber(obj) && isNaN(obj);    }    //判断obj是否为Boolean类型    _.isBoolean = function(obj) {        return obj === true || obj === false || toString.call(obj) === '[object Boolean]';    }    //判断对象是否为null    _.isNull = function(obj) {        return obj === null;    }    //判断对象是否是undefined    //undefined == null     //null表示无值，而undefined表示一个未声明的变量，或已声明但没有赋值的变量，或一个并不存在的对象属性    _.isUndefined = function(obj) {        return obj === void 0;    }    _.has = function(obj, path) {        //判断path是否是数组，如果不是数组，则判断path是不是obj原型链上的key，        //hasOwnProperty返回boolean值，指示对象自身是否具有某key（不包含原型链上的key）        if (!_.isArray(path)) {            return obj != null && hasOwnProperty.call(obj, path);        }        //如果path是数组的话，循环遍历去取值判断        var length = path.length;        for (var i = 0; i < length; i++) {            var key = path[i];            if (obj == null || !hasOwnProperty.call(obj, key)) return false;            obj = obj[key];        }        return !!length;    }    // 放弃Underscore的控制变量“_”.返回Underscore对象的引用    _.noConflict = function() {        root._ = previousUnderscore;        return this;    }    //返回与传入参数相等的值. 相当于数学里的: f(x) = x    //在Underscore里被用作默认的迭代器iterator    _.identity = function(value) {        return value;    }    //返回函数参数的传入参数     //TODO:啥用？    _.constant = function(value) {        return function() {            return value;        };    }    _.noop = function() {};    //先传入key，在取对象obj，去obj里找key对应的value值    _.property = function(path) {        if (!_.isArray(path)) {            return shallowProperty(path);        }        return function(obj) {            return deepGet(obj, path);        }    }    //如果path不是数组的话，返回obj的path属性值；    //如果path是数组的话，取obj按path对应的去找相应属性，    _.propertyOf = function(obj) {        if (obj == null) {            return function() {};        }        return function(path) {            return !_.isArray(path) ? obj[path] : deepGet(obj, path);        }    }    //取attrs里的参数（不包括继承过来的）    _.matcher = _.matches = function(attrs) {        attrs = _.extendOwn({}, attrs);        return function(obj) {            return _.isMatch(obj, attrs);        };    };    //调用iteratee方法n次，每次传入index参数，生成一个返回值数组    _.times = function(n, iteratee, context) {        var accm = Array(Math.max(0, n));        iteratee = optimizeCb(iteratee, context, 1);        for (var i = 0; i < n; i++) accm[i] = iteratee(i);        return accm;    };    //取min和max之间的随机数    //Math.floor()向下取整数，如Math.floor(4.9)为4，Math.floor(-4.9)为-5    _.random = function(min, max) {        if (max == null) {            max = min;            min = 0;        }        return min + Math.floor(Math.random() * (max - min + 1));    };    //返回当前的“时间戳”（单位ms）    //其实不是时间戳，时间戳还要除以1000（单位s）    _.now = Date.now || function() {        return new Date().getTime();    };    //能将这些特殊字符转化为实体编码    var escapeMap = {        '&': '&amp;',        '<': '&lt;',        '>': '&gt;',        '"': '&quot;',        "'": '&#x27;',        "`": '&#x60'    };    var unescapeMap = _.invert(escapeMap);    //html转义或者不转义这些字符    var createEscaper = function(map) {        var escaper = function(match) {            return map[match];        };        var source = '(?:' + _.keys(map).join('|') + ')';        var testRegexp = RegExp(source);        var replaceRegexp = RegExp(source, 'g');        return function(string) {            string = string == null ? '' : '' + string;            return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;        }    }    //编码，防止被xss攻击等一些安全隐患    _.escape = createEscaper(escapeMap);    //解码    _.unescape = createEscaper(unescapeMap);    //如果path为函数，则obj调用该函数，否则，返回path    //如果提供默认值，而obj中不存在path属性，则返回fallback    _.result = function(obj, path, fallback) {        if (!_.isArray(path)) path = [path];        var length = path.length;        //当没传入path值时候，返回fallback        if (!length) {            return _.isFunction(fallback) ? fallback.call(obj) : fallback;        }        for (var i = 0; i < length; i++) {            var prop = obj == null ? void 0 : obj[path[i]];            if (prop === void 0) {                prop = fallback;                i = length;            }            obj = _.isFunction(prop) ? prop.call(obj) : prop;        }        return obj;    }    //为需要的客户端模型或dom元素生成一个全局唯一的id，如果prefix存在，则将id赋给它    var idCounter = 0;    _.uniqueId = function(prefix) {        var id = ++idCounter + '';        return prefix ? prefix + id : id;    }    //模板的正则规则    _.templateSetting = {        evaluate: /<%([\s\S]+?)%>/g, //执行任意的js代码        interpolate: /<%=([\s\S]+?)%>/g, //插入变量        escape: /<%-([\s\S]+?)>/g //插入一个值，并让其进行HTML转义    };    var noMatch = /(.)^/;    //将这些字符显示出来，不做处理    var escape = {        "'": "'",        "\\": "\\",        "\r": "r", //回车符        "\n": "n", //换行符        "\u2018": "u2018", //line separator        "\u2019": "u2019" //Paragraph separator    }    var escapeRegExp = /\\|'|\r|\n|\u2018|\u2029/g;    var escapeChar = function(match) {        return '\\' + escape[match];    }    //将javascript模板编译为可以用于页面呈现的函数。    //函数模板使用<%=...%>插入变量，也可以用<%...%>执行js代码    //TODO: 后面研究    _.template = function() {    }    //链式    _.chain = function(obj) {        var instance = _(obj);        instance._chain = true;        return instance;    }    var chainResult = function(instance, obj) {        return instance._chain ? _(obj).chain() : obj;    };    //可向underscore扩展自己的方法    _.mixin = function(obj) {        _.each(_.functions(obj), function(name) {            var func = _[name] = obj[name];            _.prototype[name] = function() {                var args = [this._wrapped];                push.apply(args, arguments);                return chainResult(this, func.apply(_, args));            };        });        return _;    }    //将所有underscore方法加到wrapper对象里，_._wrapped.prototype = _;    _.mixin(_);    //获取原生方法，不是很理解    _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {        var method = ArrayProto[name];        _.prototype[name] = function() {            var obj = this._wrapped;            method.apply(obj, arguments);            //TODO: 为什么要delete obj[0]？            if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];            return chainResult(this, obj);        }    });    //获取原生的contact，join，slice方法    _.each(['concat', 'join', 'slice'], function(name) {        var method = ArrayProto[name];        _.prototype[name] = function() {            return chainResult(this, method.apply(this._wrapped, arguments));        }    });    //返回传入的obj本身    _.prototype.value = function() {        return this._wrapped;    }    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;    //将原本传入的obj转换为String    _.prototype.toString = function() {        return String(this._wrapped);    }    //兼容AMD规范，即“异步模块定义”，主要实现比如RequireJS，其模块引用方式：define(id?,dependencies?,factory);    if (typeof define == 'function' && define.amd) {        define('underscore', [], function() {            return _;        });    };}());